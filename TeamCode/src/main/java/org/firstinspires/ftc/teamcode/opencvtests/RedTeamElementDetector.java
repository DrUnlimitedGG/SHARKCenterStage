package org.firstinspires.ftc.teamcode.opencvtests;

import org.firstinspires.ftc.robotcore.external.Telemetry;
import org.opencv.core.*;

import org.opencv.imgproc.*;
import org.openftc.easyopencv.OpenCvPipeline;

/**
 * RedTeamElement class.
 *
 * <p>An OpenCV pipeline generated by GRIP.
 *
 * @author GRIP
 */
public class RedTeamElementDetector extends OpenCvPipeline {

    // Initialize Telemetry

    // Counts the number of pixels from the mask to determine which region is more likely
    private static int countPixels (Mat image) {
        int pixelCount = 0;

        // Iterate through each pixel
        for (int y = 0; y < image.rows(); y++) {
            for (int x = 0; x < image.cols(); x++) {
                double[] pixel = image.get(y, x);

                // Check if pixel is nonzero and increment
                if (pixel[0] > 1) {
                    pixelCount++;
                }
            }
        }

        return pixelCount;
    }

    Telemetry telemetry;
    double blurRadius = 5;
    static int position;
    static int rightAreaPixelCount;
    static int middleAreaPixelCount;
    Mat hsvThreshOutput = new Mat();
    Mat maskOutput = new Mat();




    /**
     * This is the primary method that runs the entire pipeline and updates the outputs.
     */
    public Mat processFrame (Mat input) {

        Mat processorInput = input;

        // Assign points for submats

        Point RIGHT_AREA_BOX_UPPER_LEFT = new Point(150, 300);
        Point RIGHT_AREA_BOX_LOWER_RIGHT = new Point(250, 475);

        Point MIDDLE_AREA_BOX_UPPER_LEFT = new Point(200, 0);
        Point MIDDLE_AREA_BOX_LOWER_RIGHT = new Point(300, 250);


        // Convert from RGB -> HSV
        Imgproc.cvtColor(input, processorInput, Imgproc.COLOR_RGB2HSV);

        // Blur the image
        boxBlur(processorInput, blurRadius, processorInput);

        // Filter the team element out
        double[] hsvThresholdHue = {30, 50};
        double[] hsvThresholdSaturation = {240, 255};
        double[] hsvThresholdValue = {0, 255.0};
        hsvThreshold(processorInput, hsvThresholdHue, hsvThresholdSaturation, hsvThresholdValue, hsvThreshOutput);

        // Step Mask0:
        Mat maskInput = processorInput;
        mask(input, hsvThreshOutput, maskOutput);

        // Create submats of the regions to count the number of pixels
        Mat rightAreaMat = hsvThreshOutput.submat(new Rect(RIGHT_AREA_BOX_UPPER_LEFT, RIGHT_AREA_BOX_LOWER_RIGHT));
        Mat middleAreaMat = hsvThreshOutput.submat(new Rect(MIDDLE_AREA_BOX_UPPER_LEFT, MIDDLE_AREA_BOX_LOWER_RIGHT));

        // Count pixels and return data to telemetry
        rightAreaPixelCount = countPixels(rightAreaMat);
        middleAreaPixelCount = countPixels(middleAreaMat);



        // Convert color space back for viewability
        Imgproc.cvtColor(input, processorInput, Imgproc.COLOR_HSV2RGB_FULL);

        // Determine region that the team element is located in
        if(rightAreaPixelCount > middleAreaPixelCount + 1000)
        {
            position = 3;
            Imgproc.rectangle(processorInput, RIGHT_AREA_BOX_UPPER_LEFT, RIGHT_AREA_BOX_LOWER_RIGHT, new Scalar(0, 255, 0), 2);
            Imgproc.rectangle(processorInput, MIDDLE_AREA_BOX_UPPER_LEFT, MIDDLE_AREA_BOX_LOWER_RIGHT, new Scalar(255, 0, 0), 2);
        }
        else if (middleAreaPixelCount > rightAreaPixelCount + 1000)
        {
            position = 2;
            Imgproc.rectangle(processorInput, RIGHT_AREA_BOX_UPPER_LEFT, RIGHT_AREA_BOX_LOWER_RIGHT, new Scalar(255, 0, 0), 2);
            Imgproc.rectangle(processorInput, MIDDLE_AREA_BOX_UPPER_LEFT, MIDDLE_AREA_BOX_LOWER_RIGHT, new Scalar(0, 255, 0), 2);
        }
        else
        {
            position = 1;
            Imgproc.rectangle(processorInput, RIGHT_AREA_BOX_UPPER_LEFT, RIGHT_AREA_BOX_LOWER_RIGHT, new Scalar(255, 0, 0), 2);
            Imgproc.rectangle(processorInput, MIDDLE_AREA_BOX_UPPER_LEFT, MIDDLE_AREA_BOX_LOWER_RIGHT, new Scalar(255, 0, 0), 2);
        }


        return processorInput;
    }

    static int getPosition()
    {
        return position;
    }

    static int rightAreaCount()
    {
        return rightAreaPixelCount;
    }

    static int middleAreaCount()
    {
        return middleAreaPixelCount;
    }
    /**
     * @param input image to apply blur
     * @param doubleRadius blur radius
     * @param output image to store blurred image
     */

    private void boxBlur(Mat input, double doubleRadius, Mat output) {
        int radius = (int)(doubleRadius + 0.5);
        int kernelSize;
        kernelSize = 2 * radius + 1;
        Imgproc.blur(input, output, new Size(kernelSize, kernelSize));
    }

    /**
     * @param input image on which to apply the threshold
     * @param hue minimum and maximum hue values allowed
     * @param sat minimum and maximum saturation values allowed
     * @param val minimum and maxium value values allowed
     * @param out image to store the output on
     */

    private void hsvThreshold(Mat input, double[] hue, double[] sat, double[] val,
                              Mat out) {
        Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2HSV);
        Core.inRange(out, new Scalar(hue[0], sat[0], val[0]),
                new Scalar(hue[1], sat[1], val[1]), out);
    }

    /**
     * Filter out an area of an image using a binary mask.
     * @param input The image on which the mask filters.
     * @param mask The binary image that is used to filter.
     * @param output The image in which to store the output.
     */
    private void mask(Mat input, Mat mask, Mat output) {
        mask.convertTo(mask, CvType.CV_8U);
        input.copyTo(output, mask);
    }




}

