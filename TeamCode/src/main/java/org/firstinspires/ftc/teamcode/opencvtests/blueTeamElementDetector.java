package org.firstinspires.ftc.teamcode.opencvtests;

import org.firstinspires.ftc.robotcore.external.Telemetry;
import org.opencv.core.*;

import org.opencv.imgproc.*;
import org.openftc.easyopencv.OpenCvPipeline;

/**
 * RedTeamElement class.
 *
 * <p>An OpenCV pipeline generated by GRIP.
 *
 * @author GRIP
 */
public class blueTeamElementDetector extends OpenCvPipeline {

    //Outputs

    private static int countPixels (Mat image) {
        int pixelCount = 0;

        // Iterate through each pixel
        for (int y = 0; y < image.rows(); y++) {
            for (int x = 0; x < image.cols(); x++) {
                // Get the BGR values of the current pixel
                double[] pixel = image.get(y, x);

                // Check if the pixel is red (assuming a simple red color detection)
                if (pixel[0] > 1) {
                    pixelCount++;
                }
            }
        }

        return pixelCount;
    }
    private Mat blurOutput = new Mat();
    static int currentArea;
    static int rightAreaPixelCount;
    static int middleAreaPixelCount;
    private Point newPoint0Output = new Point();
    private Point newPoint1Output = new Point();
    private Mat hsvThresholdOutput = new Mat();
    private Mat maskOutput = new Mat();
    Telemetry telemetry;

    public static int getPosition() {
        return currentArea;
    }
    static int rightAreaCount()
    {
        return rightAreaPixelCount;
    }

    static int middleAreaCount()
    {
        return middleAreaPixelCount;
    }

    /**
     * This is the primary method that runs the entire pipeline and updates the outputs.
     */
    public Mat processFrame (Mat input) {
        Mat originalFrame = input;
        Mat processorInput = input;




        // Step Blur0
        BlurType blurType = BlurType.get("Box Blur");
        double blurRadius = 25;
        blur(processorInput, blurType, blurRadius, processorInput);

        // Assign points for submats

        Point RIGHT_AREA_BOX_UPPER_LEFT = new Point(150, 300);
        Point RIGHT_AREA_BOX_LOWER_RIGHT = new Point(250, 475);

        Point MIDDLE_AREA_BOX_UPPER_LEFT = new Point(200, 0);
        Point MIDDLE_AREA_BOX_LOWER_RIGHT = new Point(300, 250);


        // Step HSV_Threshold0:
        Mat hsvThreshOutput = new Mat();
        double[] hsvThresholdHue = {0, 20};
        double[] hsvThresholdSaturation = {140, 255};
        double[] hsvThresholdValue = {75, 255};
        hsvThreshold(processorInput, hsvThresholdHue, hsvThresholdSaturation, hsvThresholdValue, hsvThreshOutput);

        // Step Mask0:
        Mat maskInput = processorInput;
        Mat maskOutput = new Mat();
        mask(input, hsvThreshOutput, maskOutput);


        Mat rightAreaMat = hsvThreshOutput.submat(new Rect(RIGHT_AREA_BOX_UPPER_LEFT, RIGHT_AREA_BOX_LOWER_RIGHT));

        Mat middleAreaMat = hsvThreshOutput.submat(new Rect(MIDDLE_AREA_BOX_UPPER_LEFT, MIDDLE_AREA_BOX_LOWER_RIGHT));

        rightAreaPixelCount = countPixels(rightAreaMat);
        middleAreaPixelCount = countPixels(middleAreaMat);



        // 1 - left
        // 2 - middle
        // 3 - right

        if(rightAreaPixelCount > middleAreaPixelCount + 1000)
        {
            currentArea = 3;
            Imgproc.rectangle(processorInput, RIGHT_AREA_BOX_UPPER_LEFT, RIGHT_AREA_BOX_LOWER_RIGHT, new Scalar(0, 255, 0), 2);
            Imgproc.rectangle(processorInput, MIDDLE_AREA_BOX_UPPER_LEFT, MIDDLE_AREA_BOX_LOWER_RIGHT, new Scalar(255, 0, 0), 2);
        }
        else if (middleAreaPixelCount > rightAreaPixelCount + 1000)
        {
            currentArea = 2;
            Imgproc.rectangle(processorInput, RIGHT_AREA_BOX_UPPER_LEFT, RIGHT_AREA_BOX_LOWER_RIGHT, new Scalar(255, 0, 0), 2);
            Imgproc.rectangle(processorInput, MIDDLE_AREA_BOX_UPPER_LEFT, MIDDLE_AREA_BOX_LOWER_RIGHT, new Scalar(0, 255, 0), 2);
        }
        else
        {
            currentArea = 1;
            Imgproc.rectangle(processorInput, RIGHT_AREA_BOX_UPPER_LEFT, RIGHT_AREA_BOX_LOWER_RIGHT, new Scalar(255, 0, 0), 2);
            Imgproc.rectangle(processorInput, MIDDLE_AREA_BOX_UPPER_LEFT, MIDDLE_AREA_BOX_LOWER_RIGHT, new Scalar(255, 0, 0), 2);
        }
        return hsvThreshOutput;
    }

    /**
     * This method is a generated getter for the output of a Blur.
     * @return Mat output from Blur.
     */
    public Mat blurOutput() {
        return blurOutput;
    }

    /**
     * This method is a generated getter for the output of a New_Point.
     * @return Point output from New_Point.
     */
    public Point newPoint0Output() {
        return newPoint0Output;
    }

    /**
     * This method is a generated getter for the output of a New_Point.
     * @return Point output from New_Point.
     */
    public Point newPoint1Output() {
        return newPoint1Output;
    }

    /**
     * This method is a generated getter for the output of a HSV_Threshold.
     * @return Mat output from HSV_Threshold.
     */
    public Mat hsvThresholdOutput() {
        return hsvThresholdOutput;
    }

    /**
     * This method is a generated getter for the output of a Mask.
     * @return Mat output from Mask.
     */
    public Mat maskOutput() {
        return maskOutput;
    }


    /**
     * An indication of which type of filter to use for a blur.
     * Choices are BOX, GAUSSIAN, MEDIAN, and BILATERAL
     */
    enum BlurType{
        BOX("Box Blur"), GAUSSIAN("Gaussian Blur"), MEDIAN("Median Filter"),
        BILATERAL("Bilateral Filter");

        private final String label;

        BlurType(String label) {
            this.label = label;
        }

        public static BlurType get(String type) {
            if (BILATERAL.label.equals(type)) {
                return BILATERAL;
            }
            else if (GAUSSIAN.label.equals(type)) {
                return GAUSSIAN;
            }
            else if (MEDIAN.label.equals(type)) {
                return MEDIAN;
            }
            else {
                return BOX;
            }
        }

        @Override
        public String toString() {
            return this.label;
        }
    }

    /**
     * Softens an image using one of several filters.
     * @param input The image on which to perform the blur.
     * @param type The blurType to perform.
     * @param doubleRadius The radius for the blur.
     * @param output The image in which to store the output.
     */
    private void blur(Mat input, BlurType type, double doubleRadius,
                      Mat output) {
        int radius = (int)(doubleRadius + 0.5);
        int kernelSize;
        switch(type){
            case BOX:
                kernelSize = 2 * radius + 1;
                Imgproc.blur(input, output, new Size(kernelSize, kernelSize));
                break;
            case GAUSSIAN:
                kernelSize = 6 * radius + 1;
                Imgproc.GaussianBlur(input,output, new Size(kernelSize, kernelSize), radius);
                break;
            case MEDIAN:
                kernelSize = 2 * radius + 1;
                Imgproc.medianBlur(input, output, kernelSize);
                break;
            case BILATERAL:
                Imgproc.bilateralFilter(input, output, -1, radius, radius);
                break;
        }
    }

    /**
     * Fills a point with given x and y values.
     * @param x the x value to put in the point
     * @param y the y value to put in the point
     * @param point the point to fill
     */
    private Point newPoint(double x, double y, Point point) {
        point.x = x;
        point.y = y;
        return new Point(x, y);
    }


    private void hsvThreshold(Mat input, double[] hue, double[] sat, double[] val,
                              Mat out) {
        Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2HSV);
        Core.inRange(out, new Scalar(hue[0], sat[0], val[0]),
                new Scalar(hue[1], sat[1], val[1]), out);
    }

    /**
     * Filter out an area of an image using a binary mask.
     * @param input The image on which the mask filters.
     * @param mask The binary image that is used to filter.
     * @param output The image in which to store the output.
     */
    private void mask(Mat input, Mat mask, Mat output) {
        mask.convertTo(mask, CvType.CV_8U);
        input.copyTo(output, mask);
    }




}

